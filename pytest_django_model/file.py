# coding: utf-8

import os
from importlib import import_module, reload

from .objects import AttributeObject

MODULE = "pytest_django_model_generated"
FILE = f"{MODULE}.py"
FILE_HEADER = (
    "# coding: utf-8\n\n"
    "##############################################################\n"
    "# This file was generated by the plugin 'pytest-django-model'.\n"
    "# Don't modify or delete it while your tests are running.     \n"
    "##############################################################\n\n"
)

CLASS_FORMAT = "class {name}:\n"

FUNC_DEF_FORMAT = """
    def {func_name}(self):
        {original}, {tester}= self._meta.model, self
        
"""
FUNC_ASSERT_FORMAT = """
        assert {original} == {tester}"""


class FileGenerator:
    def __init__(self, original, tester):
        self.original = original
        self.tester = tester

        self.init_file()

        self.str_functions = self.get_str_functions()
        self.str_class, self.class_name = self.get_str_class()

        self.append_str_class_to_file()

    def init_file(self):
        """If the File doesn't exist, create it and add the Header.
        """
        if not os.path.isfile(FILE):
            with open(FILE, "w") as f:
                f.write(FILE_HEADER)

    def get_original_attr(self, instance, attr, breadcrumb):
        """Check Model attribute breadcrumb, create attribute with value as 
        NotImplemented if it doesn't exist. Also replace Non-Existent Class by Empty 
        Class. Then return attribute.
        """
        parents = [instance._meta.name]
        parent, *middle_attrs, attr = breadcrumb.split(".")

        for middle_attr in middle_attrs:
            if not hasattr(instance, middle_attr):
                setattr(instance, middle_attr, type(middle_attr, (), {}))
            instance = getattr(instance, middle_attr)
            parents.append(middle_attr)

        if not hasattr(instance, attr):
            attribute_object = AttributeObject(attr, NotImplemented, parents)
            setattr(instance, attr, attribute_object)

        return getattr(instance, attr)

    def get_functions(self):
        """Retrieve Class Functions in Generated File and return them as a dict.
        """
        imported_module = import_module(MODULE)

        while not hasattr(imported_module, self.class_name):
            reload(imported_module)
        else:
            imported_class = getattr(imported_module, self.class_name)

        functions = dict()
        attrs = dict(imported_class.__dict__)
        for attr, value in attrs.items():
            if callable(value):
                functions[attr] = value

        return functions

    def get_str_function(self, attr_type):
        """Create Test Function with given arguments and return it with its name.
        """
        func_name = f"test_{attr_type}"

        # Write Test Function.
        func = FUNC_DEF_FORMAT.format(
            func_name=func_name,
            original=self.original._meta.name,
            tester=self.tester._meta.name,
        )
        for attr_name, attr in getattr(self.tester._meta, attr_type).items():
            original_attr = self.get_original_attr(
                instance=self.original, attr=attr_name, breadcrumb=attr.breadcrumb
            )

            func += FUNC_ASSERT_FORMAT.format(
                original=original_attr.breadcrumb, tester=attr.breadcrumb
            )

        return func_name, func

    def get_str_functions(self):
        """Generate Test Functions and return them as dict.
        """
        str_functions = dict(
            [
                self.get_str_function("constants"),
                self.get_str_function("fields"),
                self.get_str_function("meta"),
            ]
        )
        return str_functions

    def get_str_class(self):
        """Generate Test Class and return it with its name.
        """
        class_name = f"{self.tester._meta.name}"
        str_class = CLASS_FORMAT.format(name=class_name)

        for str_function in self.str_functions.values():
            has_assert = len(str_function.splitlines()) - 3
            str_class += (str_function + "\n\n") if has_assert else ""

        return str_class, class_name

    def append_str_class_to_file(self):
        """Append Generated Class to File.
        """
        with open(FILE, "a") as f:
            f.write(self.str_class)
            f.close()
